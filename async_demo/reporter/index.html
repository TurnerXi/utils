<!doctype html>
<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Async_Mocha_Test_By_Tunrer</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{
  &quot;stats&quot;: {
    &quot;suites&quot;: 2,
    &quot;tests&quot;: 27,
    &quot;passes&quot;: 27,
    &quot;pending&quot;: 0,
    &quot;failures&quot;: 0,
    &quot;start&quot;: &quot;2017-08-01T16:18:21.812Z&quot;,
    &quot;end&quot;: &quot;2017-08-01T16:18:23.580Z&quot;,
    &quot;duration&quot;: 1768,
    &quot;testsRegistered&quot;: 27,
    &quot;passPercent&quot;: 100,
    &quot;pendingPercent&quot;: 0,
    &quot;other&quot;: 0,
    &quot;hasOther&quot;: false,
    &quot;skipped&quot;: 0,
    &quot;hasSkipped&quot;: false,
    &quot;passPercentClass&quot;: &quot;success&quot;,
    &quot;pendingPercentClass&quot;: &quot;danger&quot;
  },
  &quot;suites&quot;: {
    &quot;title&quot;: &quot;&quot;,
    &quot;suites&quot;: [
      {
        &quot;title&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n&quot;,
        &quot;suites&quot;: [],
        &quot;tests&quot;: [
          {
            &quot;title&quot;: &quot;concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 299,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;[\n  \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;,\n  \&quot;var test_concat = function (arr){\\r\\n\\t\\treturn new Promise(function(resolve,reject){\\r\\n\\t\\t\\tasync.concat(arr,query_article_by_id,function(err,results){\\r\\n\\t\\t\\t\\tresolve(results);\\r\\n\\t\\t\\t});\\r\\n\\t\\t});\\r\\n\\t}\&quot;\n]&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;);\naddContext(this, \&quot;var test_concat = \&quot;+coll.test_concat);\nreturn coll.test_concat([1,2,3]).then(function(data,err){\n\texpect(data).to.be.an(\&quot;array\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b1572a67-bd1d-454f-96d6-7b25c7c0df3d&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 100,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;detect：得到集合中满足条件的第一个数据\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;detect：得到集合中满足条件的第一个数据\&quot;);\nreturn coll.test_detect([1,2,3]).then(function(data,err){\n\texpect([1,2,3]).to.include(data);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;40a7bc88-31f4-4c12-9aa9-efeb3f1dbcac&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 200,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;each：对集合中每个元素进行异步操作\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;each：对集合中每个元素进行异步操作\&quot;);\nreturn coll.test_each([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;68cc227e-d6f6-4ddb-85c3-1e3b52e8f2d4&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 119,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;);\nreturn coll.test_eachOf([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;3b774126-d52d-43d8-b261-b5a329a62ba7&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 99,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;every/all：集合中是否每个元素都满足条件\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;every/all：集合中是否每个元素都满足条件\&quot;);\nreturn coll.test_every([0,2,3]).then(function(data,err){\n\texpect(data).to.not.be.ok;\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;9912ec6c-0830-4ea2-92a3-3c2ae2ce15ff&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;c8213eb5-0dba-4b37-9e29-308fad0a0312&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;a683459e-fc3d-48e5-a176-f9d907845e5f&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;fbfae2ad-400b-4bc5-8a77-64de892dabd7&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;f38bbc26-ce4c-4131-ac78-7b6b067e43fe&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b5deddeb-342e-4a21-bb46-7dfe8bb15f1c&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;some/any：集合中是否有至少一个元素满足条件\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;some/any：集合中是否有至少一个元素满足条件\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b6e0183d-6370-4760-833e-e1abac6d25dc&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;8c37afcd-d3e5-4736-bf21-a5f2273a8d82&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;8274d744-886d-47ff-8ff9-aa8af9c1077b&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;37c845a5-f22e-4fb0-8ab7-723a5115a560&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          }
        ],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\test\\coll.test.js&quot;,
        &quot;uuid&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
        &quot;beforeHooks&quot;: [],
        &quot;afterHooks&quot;: [],
        &quot;fullFile&quot;: &quot;D:\\coding\\git_repository\\utils\\async_demo\\test\\coll.test.js&quot;,
        &quot;passes&quot;: [
          {
            &quot;title&quot;: &quot;concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 299,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;[\n  \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;,\n  \&quot;var test_concat = function (arr){\\r\\n\\t\\treturn new Promise(function(resolve,reject){\\r\\n\\t\\t\\tasync.concat(arr,query_article_by_id,function(err,results){\\r\\n\\t\\t\\t\\tresolve(results);\\r\\n\\t\\t\\t});\\r\\n\\t\\t});\\r\\n\\t}\&quot;\n]&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;);\naddContext(this, \&quot;var test_concat = \&quot;+coll.test_concat);\nreturn coll.test_concat([1,2,3]).then(function(data,err){\n\texpect(data).to.be.an(\&quot;array\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b1572a67-bd1d-454f-96d6-7b25c7c0df3d&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 100,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;detect：得到集合中满足条件的第一个数据\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;detect：得到集合中满足条件的第一个数据\&quot;);\nreturn coll.test_detect([1,2,3]).then(function(data,err){\n\texpect([1,2,3]).to.include(data);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;40a7bc88-31f4-4c12-9aa9-efeb3f1dbcac&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 200,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;each：对集合中每个元素进行异步操作\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;each：对集合中每个元素进行异步操作\&quot;);\nreturn coll.test_each([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;68cc227e-d6f6-4ddb-85c3-1e3b52e8f2d4&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 119,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;);\nreturn coll.test_eachOf([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;3b774126-d52d-43d8-b261-b5a329a62ba7&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 99,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;every/all：集合中是否每个元素都满足条件\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;every/all：集合中是否每个元素都满足条件\&quot;);\nreturn coll.test_every([0,2,3]).then(function(data,err){\n\texpect(data).to.not.be.ok;\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;9912ec6c-0830-4ea2-92a3-3c2ae2ce15ff&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;c8213eb5-0dba-4b37-9e29-308fad0a0312&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;a683459e-fc3d-48e5-a176-f9d907845e5f&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;fbfae2ad-400b-4bc5-8a77-64de892dabd7&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;f38bbc26-ce4c-4131-ac78-7b6b067e43fe&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b5deddeb-342e-4a21-bb46-7dfe8bb15f1c&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;some/any：集合中是否有至少一个元素满足条件\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;some/any：集合中是否有至少一个元素满足条件\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b6e0183d-6370-4760-833e-e1abac6d25dc&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;8c37afcd-d3e5-4736-bf21-a5f2273a8d82&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;8274d744-886d-47ff-8ff9-aa8af9c1077b&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
            &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;);&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;37c845a5-f22e-4fb0-8ab7-723a5115a560&quot;,
            &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          }
        ],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasBeforeHooks&quot;: false,
        &quot;hasAfterHooks&quot;: false,
        &quot;hasTests&quot;: true,
        &quot;hasSuites&quot;: false,
        &quot;totalTests&quot;: 14,
        &quot;totalPasses&quot;: 14,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: true,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 817,
        &quot;rootEmpty&quot;: false
      },
      {
        &quot;title&quot;: &quot;async模块Control Flow测试&quot;,
        &quot;suites&quot;: [],
        &quot;tests&quot;: [
          {
            &quot;title&quot;: &quot;applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;);\nvar laugh = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;laughing....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\nvar cry = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;cry.....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\t\nreturn coll.test_applyEach([laugh,cry],\&quot;snooby\&quot;,\&quot;test\&quot;,function(result){\n\tconsole.log(\&quot;callback1:\&quot;+result);\n},function(results){\n\tconsole.log(\&quot;callback2:\&quot;+results);\n}).then(function(data,err){\n\texpect(data).to.be.eq(\&quot;all finished....\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;15645da3-bd68-4e68-91f9-b5ec186cc005&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;[\n  \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;,\n  \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;,\n  \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;\n]&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;);\naddContext(this, \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;);\naddContext(this, \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_auto({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(results,callback){\n\t\tconsole.log(results);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n},2).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;280b9853-5785-4298-8a48-2aebfc8ec152&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 16,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_autoInject({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(laugh,cry,callback){\n\t\tconsole.log(\&quot;laugh:\&quot;+laugh);\n\t\tconsole.log(\&quot;cry:\&quot;+cry);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n}).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;afb01b0c-9c5d-47df-bf2c-13188ad188b8&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;cargo【搬运】测试：监听每一批task入栈并处理&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 cargo【搬运】测试：监听每一批task入栈并处理&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;);\nreturn coll.test_cargo(function(tasks,callback){\n\tconsole.log(tasks);\n\tcallback.call();\n},2).then(function(data,err){\n\tdata.push({name:\&quot;andy\&quot;},function(err){\n\t\tconsole.log(\&quot;andy say hi \&quot;);\n\t});\n\tdata.push({name:\&quot;turner\&quot;},function(err){\n\t\tconsole.log(\&quot;turner say hi \&quot;);\n\t});\n\texpect(data).to.be.an(\&quot;object\&quot;);\n})&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;869c9940-4621-4ea7-831a-3eb4f7fc8d52&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 47,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;medium&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;);\nfunction add1(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;add:\&quot;+n);//4\n        callback(null, n + 1);\n    }, 10);\n}\nfunction mul3(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;mul:\&quot;+n);//5\n        callback(null, n * 3);\n    }, 10);\n}\nreturn coll.test_compose(mul3,add1,4).then(function(data,err){\n\texpect(data).to.be.equal(15);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;89984510-0bae-4f3c-9f15-bd088458a909&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 117,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_whilst(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;df996f4e-bab0-4d05-9def-9fab9d6525e5&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 220,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;);\nvar count = 0;\nfunction test(callback){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\tvar delayTime = 10;\n\tif(count==2){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function(){\n\t        \tcallback(null,count&lt;5);\n\t        }, delayTime);\n\t\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(callback, delayTime);\n}\nreturn coll.test_during(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(null);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;1c5a2909-6a4d-43e4-9167-e71456857d7c&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;until【循环】测试：whilist的相反校验版本&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 until【循环】测试：whilist的相反校验版本&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 102,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&gt;=5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_until(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;322099cf-3f76-4f3c-ac87-2a5e8d3e5808&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 115,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_doWhilst(iteratee,test).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b01a0545-2ebd-45da-bbb8-9c08d24b3008&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;);\nvar count = 0;\nfunction iteratee(next){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4\n\tcount++;\n\tvar delayTime = 10;\n\tif(count&lt;=4){\n\t\tnext();\n\t}else{\n\t\tnext(count);\n\t}\n}\nreturn coll.test_forever(iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;8ad769bd-5f9c-4db5-91f4-3b8569e64787&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 216,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_parallel([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data[0]).to.equal(\&quot;one\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;04611b44-c128-404f-bd64-315caaf8e75c&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;queue【队列】测试：一个worker处理所有push进来的task&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 queue【队列】测试：一个worker处理所有push进来的task&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;);\nvar count = 0;\nfunction worker(task,callback){\n\tcount ++ ;\n\tcallback();\n}\nreturn coll.test_queue(worker,2).then(function(data,err){\n\tdata.push({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to jim\&quot;);\t\n\t});\n\tdata.push({name:\&quot;tom\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to tom\&quot;);\n\t});\n\tdata.push({name:\&quot;lily\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to lily\&quot;);\n\t});\n\tdata.unshift({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;say hi to jim again\&quot;);\n\t});\n\tdata.drain = function(){\n\t\tconsole.log(\&quot;all task have bean executed \&quot;);\n\t\texpect(count).to.be.equal(5);\n\t}\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;cb4d6a4d-5a7a-425b-b137-fc56e5526dfa&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 116,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;callback可以获取优先返回的值\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;callback可以获取优先返回的值\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_race([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data).to.equal(\&quot;two\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;9cc4f7a5-5f90-4654-bfd7-7901ef3f4aec&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          }
        ],
        &quot;pending&quot;: [],
        &quot;root&quot;: false,
        &quot;_timeout&quot;: 2000,
        &quot;file&quot;: &quot;\\test\\coll.test.js&quot;,
        &quot;uuid&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
        &quot;beforeHooks&quot;: [],
        &quot;afterHooks&quot;: [],
        &quot;fullFile&quot;: &quot;D:\\coding\\git_repository\\utils\\async_demo\\test\\coll.test.js&quot;,
        &quot;passes&quot;: [
          {
            &quot;title&quot;: &quot;applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;);\nvar laugh = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;laughing....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\nvar cry = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;cry.....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\t\nreturn coll.test_applyEach([laugh,cry],\&quot;snooby\&quot;,\&quot;test\&quot;,function(result){\n\tconsole.log(\&quot;callback1:\&quot;+result);\n},function(results){\n\tconsole.log(\&quot;callback2:\&quot;+results);\n}).then(function(data,err){\n\texpect(data).to.be.eq(\&quot;all finished....\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;15645da3-bd68-4e68-91f9-b5ec186cc005&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;[\n  \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;,\n  \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;,\n  \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;\n]&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;);\naddContext(this, \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;);\naddContext(this, \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_auto({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(results,callback){\n\t\tconsole.log(results);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n},2).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;280b9853-5785-4298-8a48-2aebfc8ec152&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 16,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this, \&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_autoInject({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(laugh,cry,callback){\n\t\tconsole.log(\&quot;laugh:\&quot;+laugh);\n\t\tconsole.log(\&quot;cry:\&quot;+cry);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n}).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;afb01b0c-9c5d-47df-bf2c-13188ad188b8&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;cargo【搬运】测试：监听每一批task入栈并处理&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 cargo【搬运】测试：监听每一批task入栈并处理&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;);\nreturn coll.test_cargo(function(tasks,callback){\n\tconsole.log(tasks);\n\tcallback.call();\n},2).then(function(data,err){\n\tdata.push({name:\&quot;andy\&quot;},function(err){\n\t\tconsole.log(\&quot;andy say hi \&quot;);\n\t});\n\tdata.push({name:\&quot;turner\&quot;},function(err){\n\t\tconsole.log(\&quot;turner say hi \&quot;);\n\t});\n\texpect(data).to.be.an(\&quot;object\&quot;);\n})&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;869c9940-4621-4ea7-831a-3eb4f7fc8d52&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 47,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;medium&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;);\nfunction add1(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;add:\&quot;+n);//4\n        callback(null, n + 1);\n    }, 10);\n}\nfunction mul3(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;mul:\&quot;+n);//5\n        callback(null, n * 3);\n    }, 10);\n}\nreturn coll.test_compose(mul3,add1,4).then(function(data,err){\n\texpect(data).to.be.equal(15);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;89984510-0bae-4f3c-9f15-bd088458a909&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 117,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_whilst(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;df996f4e-bab0-4d05-9def-9fab9d6525e5&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 220,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;);\nvar count = 0;\nfunction test(callback){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\tvar delayTime = 10;\n\tif(count==2){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function(){\n\t        \tcallback(null,count&lt;5);\n\t        }, delayTime);\n\t\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(callback, delayTime);\n}\nreturn coll.test_during(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(null);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;1c5a2909-6a4d-43e4-9167-e71456857d7c&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;until【循环】测试：whilist的相反校验版本&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 until【循环】测试：whilist的相反校验版本&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 102,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&gt;=5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_until(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;322099cf-3f76-4f3c-ac87-2a5e8d3e5808&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 115,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_doWhilst(iteratee,test).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;b01a0545-2ebd-45da-bbb8-9c08d24b3008&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;);\nvar count = 0;\nfunction iteratee(next){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4\n\tcount++;\n\tvar delayTime = 10;\n\tif(count&lt;=4){\n\t\tnext();\n\t}else{\n\t\tnext(count);\n\t}\n}\nreturn coll.test_forever(iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;8ad769bd-5f9c-4db5-91f4-3b8569e64787&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 216,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_parallel([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data[0]).to.equal(\&quot;one\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;04611b44-c128-404f-bd64-315caaf8e75c&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;queue【队列】测试：一个worker处理所有push进来的task&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 queue【队列】测试：一个worker处理所有push进来的task&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 0,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;fast&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;);\nvar count = 0;\nfunction worker(task,callback){\n\tcount ++ ;\n\tcallback();\n}\nreturn coll.test_queue(worker,2).then(function(data,err){\n\tdata.push({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to jim\&quot;);\t\n\t});\n\tdata.push({name:\&quot;tom\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to tom\&quot;);\n\t});\n\tdata.push({name:\&quot;lily\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to lily\&quot;);\n\t});\n\tdata.unshift({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;say hi to jim again\&quot;);\n\t});\n\tdata.drain = function(){\n\t\tconsole.log(\&quot;all task have bean executed \&quot;);\n\t\texpect(count).to.be.equal(5);\n\t}\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;cb4d6a4d-5a7a-425b-b137-fc56e5526dfa&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          },
          {
            &quot;title&quot;: &quot;race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
            &quot;fullTitle&quot;: &quot;async模块Control Flow测试 race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
            &quot;timedOut&quot;: false,
            &quot;duration&quot;: 116,
            &quot;state&quot;: &quot;passed&quot;,
            &quot;speed&quot;: &quot;slow&quot;,
            &quot;pass&quot;: true,
            &quot;fail&quot;: false,
            &quot;pending&quot;: false,
            &quot;context&quot;: &quot;\&quot;callback可以获取优先返回的值\&quot;&quot;,
            &quot;code&quot;: &quot;addContext(this,\&quot;callback可以获取优先返回的值\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_race([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data).to.equal(\&quot;two\&quot;);\n});&quot;,
            &quot;err&quot;: {},
            &quot;isRoot&quot;: false,
            &quot;uuid&quot;: &quot;9cc4f7a5-5f90-4654-bfd7-7901ef3f4aec&quot;,
            &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
            &quot;isHook&quot;: false,
            &quot;skipped&quot;: false
          }
        ],
        &quot;failures&quot;: [],
        &quot;skipped&quot;: [],
        &quot;hasBeforeHooks&quot;: false,
        &quot;hasAfterHooks&quot;: false,
        &quot;hasTests&quot;: true,
        &quot;hasSuites&quot;: false,
        &quot;totalTests&quot;: 13,
        &quot;totalPasses&quot;: 13,
        &quot;totalFailures&quot;: 0,
        &quot;totalPending&quot;: 0,
        &quot;totalSkipped&quot;: 0,
        &quot;hasPasses&quot;: true,
        &quot;hasFailures&quot;: false,
        &quot;hasPending&quot;: false,
        &quot;hasSkipped&quot;: false,
        &quot;duration&quot;: 949,
        &quot;rootEmpty&quot;: false
      }
    ],
    &quot;tests&quot;: [],
    &quot;pending&quot;: [],
    &quot;root&quot;: true,
    &quot;_timeout&quot;: 2000,
    &quot;uuid&quot;: &quot;214aa694-9f2c-46ac-8008-4aaa679a46a0&quot;,
    &quot;beforeHooks&quot;: [],
    &quot;afterHooks&quot;: [],
    &quot;fullFile&quot;: &quot;&quot;,
    &quot;file&quot;: &quot;&quot;,
    &quot;passes&quot;: [],
    &quot;failures&quot;: [],
    &quot;skipped&quot;: [],
    &quot;hasBeforeHooks&quot;: false,
    &quot;hasAfterHooks&quot;: false,
    &quot;hasTests&quot;: false,
    &quot;hasSuites&quot;: true,
    &quot;totalTests&quot;: 0,
    &quot;totalPasses&quot;: 0,
    &quot;totalFailures&quot;: 0,
    &quot;totalPending&quot;: 0,
    &quot;totalSkipped&quot;: 0,
    &quot;hasPasses&quot;: false,
    &quot;hasFailures&quot;: false,
    &quot;hasPending&quot;: false,
    &quot;hasSkipped&quot;: false,
    &quot;duration&quot;: 0,
    &quot;rootEmpty&quot;: true
  },
  &quot;allTests&quot;: [
    {
      &quot;title&quot;: &quot;concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 299,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;[\n  \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;,\n  \&quot;var test_concat = function (arr){\\r\\n\\t\\treturn new Promise(function(resolve,reject){\\r\\n\\t\\t\\tasync.concat(arr,query_article_by_id,function(err,results){\\r\\n\\t\\t\\t\\tresolve(results);\\r\\n\\t\\t\\t});\\r\\n\\t\\t});\\r\\n\\t}\&quot;\n]&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;);\naddContext(this, \&quot;var test_concat = \&quot;+coll.test_concat);\nreturn coll.test_concat([1,2,3]).then(function(data,err){\n\texpect(data).to.be.an(\&quot;array\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b1572a67-bd1d-454f-96d6-7b25c7c0df3d&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 100,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;detect：得到集合中满足条件的第一个数据\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;detect：得到集合中满足条件的第一个数据\&quot;);\nreturn coll.test_detect([1,2,3]).then(function(data,err){\n\texpect([1,2,3]).to.include(data);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;40a7bc88-31f4-4c12-9aa9-efeb3f1dbcac&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 200,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;each：对集合中每个元素进行异步操作\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;each：对集合中每个元素进行异步操作\&quot;);\nreturn coll.test_each([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;68cc227e-d6f6-4ddb-85c3-1e3b52e8f2d4&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 119,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;);\nreturn coll.test_eachOf([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3b774126-d52d-43d8-b261-b5a329a62ba7&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 99,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;every/all：集合中是否每个元素都满足条件\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;every/all：集合中是否每个元素都满足条件\&quot;);\nreturn coll.test_every([0,2,3]).then(function(data,err){\n\texpect(data).to.not.be.ok;\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9912ec6c-0830-4ea2-92a3-3c2ae2ce15ff&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c8213eb5-0dba-4b37-9e29-308fad0a0312&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a683459e-fc3d-48e5-a176-f9d907845e5f&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fbfae2ad-400b-4bc5-8a77-64de892dabd7&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f38bbc26-ce4c-4131-ac78-7b6b067e43fe&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b5deddeb-342e-4a21-bb46-7dfe8bb15f1c&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;some/any：集合中是否有至少一个元素满足条件\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;some/any：集合中是否有至少一个元素满足条件\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b6e0183d-6370-4760-833e-e1abac6d25dc&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8c37afcd-d3e5-4736-bf21-a5f2273a8d82&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8274d744-886d-47ff-8ff9-aa8af9c1077b&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;37c845a5-f22e-4fb0-8ab7-723a5115a560&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;);\nvar laugh = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;laughing....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\nvar cry = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;cry.....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\t\nreturn coll.test_applyEach([laugh,cry],\&quot;snooby\&quot;,\&quot;test\&quot;,function(result){\n\tconsole.log(\&quot;callback1:\&quot;+result);\n},function(results){\n\tconsole.log(\&quot;callback2:\&quot;+results);\n}).then(function(data,err){\n\texpect(data).to.be.eq(\&quot;all finished....\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;15645da3-bd68-4e68-91f9-b5ec186cc005&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;[\n  \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;,\n  \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;,\n  \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;\n]&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;);\naddContext(this, \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;);\naddContext(this, \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_auto({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(results,callback){\n\t\tconsole.log(results);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n},2).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;280b9853-5785-4298-8a48-2aebfc8ec152&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 16,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_autoInject({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(laugh,cry,callback){\n\t\tconsole.log(\&quot;laugh:\&quot;+laugh);\n\t\tconsole.log(\&quot;cry:\&quot;+cry);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n}).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;afb01b0c-9c5d-47df-bf2c-13188ad188b8&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;cargo【搬运】测试：监听每一批task入栈并处理&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 cargo【搬运】测试：监听每一批task入栈并处理&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;);\nreturn coll.test_cargo(function(tasks,callback){\n\tconsole.log(tasks);\n\tcallback.call();\n},2).then(function(data,err){\n\tdata.push({name:\&quot;andy\&quot;},function(err){\n\t\tconsole.log(\&quot;andy say hi \&quot;);\n\t});\n\tdata.push({name:\&quot;turner\&quot;},function(err){\n\t\tconsole.log(\&quot;turner say hi \&quot;);\n\t});\n\texpect(data).to.be.an(\&quot;object\&quot;);\n})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;869c9940-4621-4ea7-831a-3eb4f7fc8d52&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 47,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;medium&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;);\nfunction add1(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;add:\&quot;+n);//4\n        callback(null, n + 1);\n    }, 10);\n}\nfunction mul3(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;mul:\&quot;+n);//5\n        callback(null, n * 3);\n    }, 10);\n}\nreturn coll.test_compose(mul3,add1,4).then(function(data,err){\n\texpect(data).to.be.equal(15);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;89984510-0bae-4f3c-9f15-bd088458a909&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 117,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_whilst(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;df996f4e-bab0-4d05-9def-9fab9d6525e5&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 220,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;);\nvar count = 0;\nfunction test(callback){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\tvar delayTime = 10;\n\tif(count==2){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function(){\n\t        \tcallback(null,count&lt;5);\n\t        }, delayTime);\n\t\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(callback, delayTime);\n}\nreturn coll.test_during(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(null);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1c5a2909-6a4d-43e4-9167-e71456857d7c&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;until【循环】测试：whilist的相反校验版本&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 until【循环】测试：whilist的相反校验版本&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 102,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&gt;=5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_until(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;322099cf-3f76-4f3c-ac87-2a5e8d3e5808&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 115,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_doWhilst(iteratee,test).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b01a0545-2ebd-45da-bbb8-9c08d24b3008&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;);\nvar count = 0;\nfunction iteratee(next){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4\n\tcount++;\n\tvar delayTime = 10;\n\tif(count&lt;=4){\n\t\tnext();\n\t}else{\n\t\tnext(count);\n\t}\n}\nreturn coll.test_forever(iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8ad769bd-5f9c-4db5-91f4-3b8569e64787&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 216,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_parallel([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data[0]).to.equal(\&quot;one\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;04611b44-c128-404f-bd64-315caaf8e75c&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;queue【队列】测试：一个worker处理所有push进来的task&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 queue【队列】测试：一个worker处理所有push进来的task&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;);\nvar count = 0;\nfunction worker(task,callback){\n\tcount ++ ;\n\tcallback();\n}\nreturn coll.test_queue(worker,2).then(function(data,err){\n\tdata.push({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to jim\&quot;);\t\n\t});\n\tdata.push({name:\&quot;tom\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to tom\&quot;);\n\t});\n\tdata.push({name:\&quot;lily\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to lily\&quot;);\n\t});\n\tdata.unshift({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;say hi to jim again\&quot;);\n\t});\n\tdata.drain = function(){\n\t\tconsole.log(\&quot;all task have bean executed \&quot;);\n\t\texpect(count).to.be.equal(5);\n\t}\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cb4d6a4d-5a7a-425b-b137-fc56e5526dfa&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 116,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;callback可以获取优先返回的值\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;callback可以获取优先返回的值\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_race([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data).to.equal(\&quot;two\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9cc4f7a5-5f90-4654-bfd7-7901ef3f4aec&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allPending&quot;: [],
  &quot;allPasses&quot;: [
    {
      &quot;title&quot;: &quot;concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n concat【连接】测试：iteratee遍历完所有集合后才会调用handler,每次遍历向callback传入的参数组成一个集合作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 299,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;[\n  \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;,\n  \&quot;var test_concat = function (arr){\\r\\n\\t\\treturn new Promise(function(resolve,reject){\\r\\n\\t\\t\\tasync.concat(arr,query_article_by_id,function(err,results){\\r\\n\\t\\t\\t\\tresolve(results);\\r\\n\\t\\t\\t});\\r\\n\\t\\t});\\r\\n\\t}\&quot;\n]&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;concat：对集合中的元素进行异步操作，将结果集合并成一个数组\&quot;);\naddContext(this, \&quot;var test_concat = \&quot;+coll.test_concat);\nreturn coll.test_concat([1,2,3]).then(function(data,err){\n\texpect(data).to.be.an(\&quot;array\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b1572a67-bd1d-454f-96d6-7b25c7c0df3d&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n detect【监听】测试：得到集合中满足条件的第一个数据，注：handler被调用后iteratee立即停止&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 100,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;detect：得到集合中满足条件的第一个数据\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;detect：得到集合中满足条件的第一个数据\&quot;);\nreturn coll.test_detect([1,2,3]).then(function(data,err){\n\texpect([1,2,3]).to.include(data);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;40a7bc88-31f4-4c12-9aa9-efeb3f1dbcac&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n each【遍历】测试：iteratee遍历coll,返回异常时调用handler&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 200,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;each：对集合中每个元素进行异步操作\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;each：对集合中每个元素进行异步操作\&quot;);\nreturn coll.test_each([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;68cc227e-d6f6-4ddb-85c3-1e3b52e8f2d4&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n eachOf【索引遍历】测试：iteratee遍历coll,iteratee参数包含index[当前item在coll中的索引],返回异常时调用handler&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 119,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;eachOf：对集合中每个元素进行异步操作, 可以每个元素在集合中的索引\&quot;);\nreturn coll.test_eachOf([1,2,3]).then(function(data,err){\n\texpect(data).to.be.empty;\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;3b774126-d52d-43d8-b261-b5a329a62ba7&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n every【校验】测试：与detect相反，iteratee遍历中返回false时立即调用handler，否则等待遍历完成调用，注：无论handler何时被调用，iteratee都会将coll遍历完成&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 99,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;every/all：集合中是否每个元素都满足条件\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;every/all：集合中是否每个元素都满足条件\&quot;);\nreturn coll.test_every([0,2,3]).then(function(data,err){\n\texpect(data).to.not.be.ok;\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9912ec6c-0830-4ea2-92a3-3c2ae2ce15ff&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n filter【过滤】测试：过滤掉coll在iteratee中返回false的item，过滤后的coll作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;c8213eb5-0dba-4b37-9e29-308fad0a0312&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n groupBy【分组】测试：对coll进行分组，iteratee中返回的值作为key，coll中相同key的item集合作为value，分组后的集合作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;groupBy：对集合中元素使用异步操作进行分组，得到分组后的集合\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;a683459e-fc3d-48e5-a176-f9d907845e5f&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n map【集合映射】测试：iteratee中对coll中的item进行处理，返回一个新的数组，若抛出异常handler立即执行&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;map：对集合中的每个元素通过异步操作得到另一个值，组成新的数组\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;fbfae2ad-400b-4bc5-8a77-64de892dabd7&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n mapValues【map值映射】测试：与map类似，coll为map，iteratee中对coll中的item.value进行处理，返回一个新的对象{item.key,newVlaue}，分组后的集合作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;mapValues：对map中的每个键值对通过异步操作得到另一组相同键不同值的键值对，组成新的map\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;f38bbc26-ce4c-4131-ac78-7b6b067e43fe&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reject【排斥】测试：与filter相反，排斥coll在iteratee中返回true的item，排斥后的coll作为handler的result&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b5deddeb-342e-4a21-bb46-7dfe8bb15f1c&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n some/any【任意】测试：当集合中是否有至少一个元素满足条件时，最终callback得到的值为true&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;some/any：集合中是否有至少一个元素满足条件\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;some/any：集合中是否有至少一个元素满足条件\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b6e0183d-6370-4760-833e-e1abac6d25dc&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n reduce/reduceRight【换算】测试：给定一个初始值，对集合中的元素做换算，返回换算后的值，如抛出错误停止循环立即执行handler，注：reduce执行方式为串行,默认从左到右,reduceRight从右到左&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8c37afcd-d3e5-4736-bf21-a5f2273a8d82&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n sortBy【排序】测试：对coll根据返回值进行排序，handler的result为排序后的集合&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8274d744-886d-47ff-8ff9-aa8af9c1077b&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
      &quot;fullTitle&quot;: &quot;Async模块Collection测试\r\n说明：\r\n每个方法都有三个参数，async.xxxx(coll,iteratee(item,callback),handler(err,result))\r\n  coll：一个集合，集合中的每个元素作为iteratee的item\r\n  iteratee：处理集合中每一个元素的子函数，集合中的每个元素作为第一个入参，第二个入参是系统的一个回调方法，iteratee向其传入的参数与handler有密切关系\r\n  callback：处理iteratee遍历后的结果，第一个参数为异常，第二个参数为回调结果，回调结果不一定是iteratee中回调方法传入的参数，callback根据主函数的不同特性，不一定会立即执行\r\n\r\n  每个方法都有三种形式:\r\n  xxx：iteratee并行\r\n  xxxLimit：iteratee限制并行个数并行\r\n  xxxSeries：iteratee串行\r\n transform【轉化】测试：与reduce类似，给定一个初始容器，返回转换后的容器，如抛出错误停止循环立即执行handler&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;transform：与reduce相似，使用一个初始容器集合中每一个元素进行异步操作，最后得到转换后的容器\&quot;);&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;37c845a5-f22e-4fb0-8ab7-723a5115a560&quot;,
      &quot;parentUUID&quot;: &quot;7a10e805-acff-4cfd-a212-bf14f1ef5cfe&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 applyEach【遍历应用】测试：并行遍历，统一回调&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;主函数中的所有参数都依次作为每个子函数的参数,最后一个参数如果是回调方法则会当所有子函数执行完后才执行\&quot;);\nvar laugh = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;laughing....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\nvar cry = function(arg1,arg2,callback1,callback2){\n\tcallback1(arg1+arg2+\&quot;cry.....\&quot;);\n\tcallback2(\&quot;all finished....\&quot;);\n}\t\nreturn coll.test_applyEach([laugh,cry],\&quot;snooby\&quot;,\&quot;test\&quot;,function(result){\n\tconsole.log(\&quot;callback1:\&quot;+result);\n},function(results){\n\tconsole.log(\&quot;callback2:\&quot;+results);\n}).then(function(data,err){\n\texpect(data).to.be.eq(\&quot;all finished....\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;15645da3-bd68-4e68-91f9-b5ec186cc005&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 auto【自动任务】测试：自动切换流程控制，返回结果映射&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;[\n  \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;,\n  \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;,\n  \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;\n]&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;1.无依赖方法参数为（callback）,callback返回结果\&quot;);\naddContext(this, \&quot;2.有依赖方法参数为（results, callback）,resutls为所依赖方法结果映射\&quot;);\naddContext(this, \&quot;3.所有函数执行完毕后执行最终回调方法（err,results）,中途抛出错误，流程立即停止\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_auto({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(results,callback){\n\t\tconsole.log(results);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n},2).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;280b9853-5785-4298-8a48-2aebfc8ec152&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 autoInject【依赖注入】测试：auto的依赖注入版本&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 16,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this, \&quot;相较于auto有更纯净的语法糖，自动注入将依赖方法的结果作为参数直接传递\&quot;);\nvar laugh = function(callback){\n\tcallback(null,\&quot;laughing....\&quot;);\n}\nvar cry = function(callback){\n\tcallback(null,\&quot;cry.....\&quot;);\n}\t\nreturn coll.test_autoInject({\n\tlaugh : laugh,\n\tcry : cry,\n\teat : [\&quot;laugh\&quot;,\&quot;cry\&quot;,function(laugh,cry,callback){\n\t\tconsole.log(\&quot;laugh:\&quot;+laugh);\n\t\tconsole.log(\&quot;cry:\&quot;+cry);\n\t\tcallback(null,\&quot;eat all..\&quot;);\n\t}]\n}).then(function(data,err){\n\texpect(data).to.be.an(\&quot;Object\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;afb01b0c-9c5d-47df-bf2c-13188ad188b8&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;cargo【搬运】测试：监听每一批task入栈并处理&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 cargo【搬运】测试：监听每一批task入栈并处理&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;一个worker处理多个task，task处理完成后调用回调方法，payload表示每一批的task数量,不指定则为无限制\&quot;);\nreturn coll.test_cargo(function(tasks,callback){\n\tconsole.log(tasks);\n\tcallback.call();\n},2).then(function(data,err){\n\tdata.push({name:\&quot;andy\&quot;},function(err){\n\t\tconsole.log(\&quot;andy say hi \&quot;);\n\t});\n\tdata.push({name:\&quot;turner\&quot;},function(err){\n\t\tconsole.log(\&quot;turner say hi \&quot;);\n\t});\n\texpect(data).to.be.an(\&quot;object\&quot;);\n})&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;869c9940-4621-4ea7-831a-3eb4f7fc8d52&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 compose【组合】测试：将若干嵌套方法组合起来倒序执行&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 47,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;medium&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;若干方法倒序依次执行( f(), g(), h()==f(g(h())) )，前一方法的返回值作为参数传递给下一方法\&quot;);\nfunction add1(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;add:\&quot;+n);//4\n        callback(null, n + 1);\n    }, 10);\n}\nfunction mul3(n, callback) {\n    setTimeout(function () {\n    \tconsole.log(\&quot;mul:\&quot;+n);//5\n        callback(null, n * 3);\n    }, 10);\n}\nreturn coll.test_compose(mul3,add1,4).then(function(data,err){\n\texpect(data).to.be.equal(15);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;89984510-0bae-4f3c-9f15-bd088458a909&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 whilst【循环】测试：异步循环，当方法体真正执行完毕调用回调方法时才进入下一次循环&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 117,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_whilst(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;df996f4e-bab0-4d05-9def-9fab9d6525e5&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 during【循环】测试：whilist的异步校验版本，最终结果不返回数据&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 220,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，当条件为真时执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback\&quot;);\nvar count = 0;\nfunction test(callback){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\tvar delayTime = 10;\n\tif(count==2){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function(){\n\t        \tcallback(null,count&lt;5);\n\t        }, delayTime);\n\t\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(callback, delayTime);\n}\nreturn coll.test_during(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(null);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;1c5a2909-6a4d-43e4-9167-e71456857d7c&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;until【循环】测试：whilist的相反校验版本&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 until【循环】测试：whilist的相反校验版本&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 102,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;test返回结果作为循环条件，直到条件为真时停止执行iteratee，iteratee调用回调方法时结束本次循环，进入下次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4,5\n\treturn count&gt;=5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_until(test,iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;322099cf-3f76-4f3c-ac87-2a5e8d3e5808&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 doWhilst【循环】测试：与whilist相同，但先进入循环再校验条件&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 115,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;首先执行iteratee，再校验test，当条件为真时进入下一次循环，当循环完毕后执行callback，并将最终结果传入callback\&quot;);\nvar count = 0;\nfunction test(){\n\tconsole.log(\&quot;count:\&quot;+count);//1,2,3,4,5\n\treturn count&lt;5;\n}\nfunction iteratee(callback){\n\tcount++;\n\tvar delayTime = 10;\n\tif(count==4){\n\t\tdelayTime = 30;\n\t}\n\t        setTimeout(function() {\n\t            callback(null, count);\n\t        }, delayTime);\n}\nreturn coll.test_doWhilst(iteratee,test).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;b01a0545-2ebd-45da-bbb8-9c08d24b3008&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 forever【无限循环】测试：需要继续循环时调用next，next参数不为空时结束循环&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;进入循环后调用next进入下一次循环，当next参数不为空时结束循环\&quot;);\nvar count = 0;\nfunction iteratee(next){\n\tconsole.log(\&quot;count:\&quot;+count);//0,1,2,3,4\n\tcount++;\n\tvar delayTime = 10;\n\tif(count&lt;=4){\n\t\tnext();\n\t}else{\n\t\tnext(count);\n\t}\n}\nreturn coll.test_forever(iteratee).then(function(data,err){\n\texpect(data).to.be.equal(5);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;8ad769bd-5f9c-4db5-91f4-3b8569e64787&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 parallel【并行】测试：并行调用funcs，结果为所有方法返回值的有序集合&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 216,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;并行执行funcs，所有func执行完毕后调用callback，results为所有方法返回值的有序集合\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_parallel([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data[0]).to.equal(\&quot;one\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;04611b44-c128-404f-bd64-315caaf8e75c&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;queue【队列】测试：一个worker处理所有push进来的task&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 queue【队列】测试：一个worker处理所有push进来的task&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 0,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;fast&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;与cargo类似，本质上是串行处理task，上一个task处理完成后才会处理下一个task\&quot;);\nvar count = 0;\nfunction worker(task,callback){\n\tcount ++ ;\n\tcallback();\n}\nreturn coll.test_queue(worker,2).then(function(data,err){\n\tdata.push({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to jim\&quot;);\t\n\t});\n\tdata.push({name:\&quot;tom\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to tom\&quot;);\n\t});\n\tdata.push({name:\&quot;lily\&quot;},function(err){\n\t\tconsole.log(\&quot;have say hi to lily\&quot;);\n\t});\n\tdata.unshift({name:\&quot;jim\&quot;},function(err){\n\t\tconsole.log(\&quot;say hi to jim again\&quot;);\n\t});\n\tdata.drain = function(){\n\t\tconsole.log(\&quot;all task have bean executed \&quot;);\n\t\texpect(count).to.be.equal(5);\n\t}\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;cb4d6a4d-5a7a-425b-b137-fc56e5526dfa&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    },
    {
      &quot;title&quot;: &quot;race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
      &quot;fullTitle&quot;: &quot;async模块Control Flow测试 race【竞赛】测试：第一个func完成将返回值传递给callback，并立即执行callback&quot;,
      &quot;timedOut&quot;: false,
      &quot;duration&quot;: 116,
      &quot;state&quot;: &quot;passed&quot;,
      &quot;speed&quot;: &quot;slow&quot;,
      &quot;pass&quot;: true,
      &quot;fail&quot;: false,
      &quot;pending&quot;: false,
      &quot;context&quot;: &quot;\&quot;callback可以获取优先返回的值\&quot;&quot;,
      &quot;code&quot;: &quot;addContext(this,\&quot;callback可以获取优先返回的值\&quot;);\nfunction func1(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;one\&quot;);\n\t\tcallback(null,\&quot;one\&quot;);\n\t},200);\n}\nfunction func2(callback){\n\tsetTimeout(function(){\n\t\tconsole.log(\&quot;two\&quot;);\n\t\tcallback(null,\&quot;two\&quot;);\n\t},100);\n}\nreturn coll.test_race([func1,func2]).then(function(data,err){\n\tconsole.log(data);\n\texpect(data).to.equal(\&quot;two\&quot;);\n});&quot;,
      &quot;err&quot;: {},
      &quot;isRoot&quot;: false,
      &quot;uuid&quot;: &quot;9cc4f7a5-5f90-4654-bfd7-7901ef3f4aec&quot;,
      &quot;parentUUID&quot;: &quot;8feee9a1-7ee1-44ec-944a-a8bd31784611&quot;,
      &quot;isHook&quot;: false,
      &quot;skipped&quot;: false
    }
  ],
  &quot;allFailures&quot;: [],
  &quot;copyrightYear&quot;: 2017
}" data-config="{&quot;reportDir&quot;:&quot;reporter&quot;,&quot;reportTitle&quot;:&quot;Async_Mocha_Test&quot;,&quot;reportPageTitle&quot;:&quot;Async_Mocha_Test_By_Tunrer&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;dev&quot;:false,&quot;reportFilename&quot;:&quot;index&quot;,&quot;saveJson&quot;:true,&quot;jsonFile&quot;:&quot;D:\\coding\\git_repository\\utils\\async_demo\\reporter\\index.json&quot;,&quot;htmlFile&quot;:&quot;D:\\coding\\git_repository\\utils\\async_demo\\reporter\\index.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>